## Содержание
* [Динамические структуры данных](#Динамические структуры данных)
* [Разновидности стркутур](#Разновидности стркутур)
* [Список](#список)

## Динамические структуры данных
Парадокс, но даже динамический массив, по сути своей не очень динамичен, так как для того, что бы изменить его размер, 
необходимо пересоздать его. Другими словами во время работы программы довольно просто изменять только значения 
элементов, в то время как изменение количества этих элементов приводит к ряду монотонных процедур. А это, конечно, 
не всегда удобно.

Предположим, что в программе, предназначенной для ввода и обработки данных об учениках класса, для хранения данных 
используются статические массивы. При определении размера массива программисту приходится ориентироваться на некоторое
среднее или предельное количество учеников в классе. При этом, если реально учеников в классе меньше предполагаемого
количества, то неэффективно используется память компьютера, а если это число больше, то программу использовать уже
нельзя (т. к. надо внести изменения в исходный текст и выполнить компиляцию). Создание динамического массива несомненно
явится решением, но приведет к усложнению написания кода.

Задачи, обрабатывающие данные, которые по своей природе являются динамическими, удобно решать с помощью динамических 
структур. 

Учитывая всё вышесказанное, можно предположить, что динамические структуры - это некие конструкции, способные при 
необходимости выделять память под новые элементы или удалять выделенную память для ненужных элементов во время работы
программы. Для решения проблемы адресации динамических структур данных используется метод, называемый динамическим 
распределением памяти, то есть память под отдельные элементы выделяется в момент, когда они "начинают существовать" 
в процессе выполнения программы, а не во время компиляции. Компилятор в этом случае только выделяет фиксированный
объем памяти для хранения адреса динамически размещаемого элемента, а не самого элемента.

Существует несколько видов динамических структур данных. При этом каждый из них имеет как достоинства, так и 
недостатки. Поэтому, какой именно вид использовать, зависит исключительно от конкретной решаемой задачи.

## Разновидности стркутур:
### Стек
* Стек (англ. stack — стопка; читается стэк) — структура данных с методом доступа к элементам LIFO 
(англ. Last In — First Out, «последним пришел — первым вышел»). Чаще всего принцип работы стека 
сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю. Наиболее наглядным
примером организации стека служит детская пирамидка, где добавление и снятие колец осуществляется 
как раз согласно определению стека.
Добавление элемента, называемое также проталкиванием (push), возможно только в вершину стека (добавленный 
элемент становится первым сверху). Удаление элемента, называемое также выталкивание (pop), возможно также 
только из вершины стека, при этом, второй сверху элемент становится верхним.
Стеки широко применяются в системном программном обеспечении, компиляторах, в различных рекурсивных алгоритмах.
### Простая очередь
* Простая очередь - динамическая структура. Очередь, так же как и стек можно реализовывать на практике с помощью 
массива. Очередь — это последовательный набор элементов с переменной длиной. При этом, добавление элементов в 
очередь происходит с одной стороны, а удаление — с другой стороны. Данная конструкция функционирует по идеологии 
FIFO (First In — First Out), то есть "первым пришел — первым вышел". Для очереди принято выделять конечную 
последовательность элементов, из которых в каждый текущий момент времени элементами очереди заняты лишь часть 
последовательных элементов. В принципе, с простой очередью вы сталкиваетесь постоянно. Вот лишь некоторые из
примеров:очередь в мавзолей, очередь печати принтера, даже действия линейного алгоритма выполняются по очереди.
### Кольцевая очередь
* Кольцевая очередь. Кольцевая очередь очень похожа на простую очередь. Она тоже построена на идеологии FIFO, 
напоминаем - элемент, который добавили в очередь первым, первым ее и покинет. Разница лишь в том, что элемент,
который выходит из начала очереди, будет перемещён в её конец. В качестве самого простого примера, можно привести 
известный вам с детства круговорот воды в природе, или трамваи, курсирующие по круговому маршруту.
### Очередь с приоритетом
* Мы уже познакомились с двумя типами очередей и они оказались достаточно простыми. Однако существует еще одна
очередь - очередь с приоритетом.
Дело в том, что часто необходимо создать очередь, где очередность выхода зависит от приоритетов элементов. 
В качестве приоритета может выступать какое-либо число, временная константа и т. п. В момент извлечения 
элемента будет выбран тот элемент, который обладает большим приоритетом.
Существует несколько видов приоритетных очередей:
1) Очередь с приоритетным включением - последовательность элементов очереди является строго упорядоченной. 
Другими словами, каждый элемент при попадании в очередь сразу же располагается согласно своего приоритета. 
А в момент исключения элемента просто извлекается элемент из начала.
2) Очереди с приоритетным исключением - элемент добавляется в конец очереди, а при извлечении осуществляется
самого приоритетного элемента, который впоследствии удаляется из очереди.
### Список
* Список - это совокупность нескольких объектов, каждый из которых представляет собой элемент
списка, состоящий из двух частей. Первая часть элемента - значение, которое он хранит, вторая - информация
о следующем элементе списка. Характер информации о следующем элементе зависит от того, где конкретно хранится
список. Например, если это оперативная память, то информация будет представлять собой адрес следующего элемента, 
если файл - позицию следующего элемента в файле.

#### Представление связного списка

Связный список можно представить в виде цепочки узлов, где каждый узел указывает на следующий:
Здесь надо учитывать следующие важные моменты:

Связный список содержит элемент ссылки, называемой first (первой).
Каждая ссылка имеет поле или поля данных и поле ссылки, называемой next (следующей).
Каждая ссылка связана со следующей посредством своей ссылки next.
Последняя ссылка содержит ссылку со значением null, обозначающую конец списка.
Типы связных списков
Различают следующие типы связных списков:

Односвязный (однонаправленный) с переходом по элементам только вперед.
Двусвязный (двунаправленный) с переходом по элементам вперед и назад.
Кольцевой (циклический, замкнутый), в последнем элементе которого содержится ссылка на первый элемент, а в первом — на последний.
Базовые операции
Это основные операции, проводимые над списками:

* Вставка, то есть добавление элемента в начало списка.
* Удаление элемента из начала списка.
* Отображение полного списка.
* Поиск элемента по заданному ключу.
* Удаление элемента по заданному ключу.



### Бинарное дерево
* Бинарное дерево (binary tree) - это упорядоченная древовидная динамическая структура. Каждый элемент (узел)
дерева имеет не более двух элементов следующих за ним (потомков) и не более одного предыдущего (родителя). 
Организация данных с помощью бинарных деревьев часто позволяет значительно сократить время поиска нужного элемента.
Поиск элемента в линейных структурах данных обычно осуществляется путем последовательного перебора всех элементов,
присутствующих в данной структуре. Поиск по дереву не требует перебора всех элементов, поэтому занимает значительно 
меньше времени. Максимальное число шагов при поиске по дереву равно высоте данного дерева, т.е. количеству уровней в
иерархической структуре дерева.